---
title: "Introduction to Devious (the R package)"
author: |
    | Prepared by:
    | Jenna Johnson
    | (jenna@a2-ai.com)
date: today
date-format: long
format:
  html:
    toc: true
    number-sections: true
    colorlinks: true
editor: visual
---

Devious is now an R package inspired by the original devious command line tool.

While it implements the same base functionality, it has some new features, and output is organized into data frames.

We can use devious to version data files without tracking them directly on github.

```{r}
# library(devious)
library(dplyr)
rextendr::document("~/Projects/Rdevious")
devtools::load_all("~/Projects/Rdevious")
```

## The Data Assembler

### 1: Initialize

Suppose I created a new repo for a project.\
I want to manage project data with devious, so I'll start with initialization.

In the devious package, `dvs_init` sets up a project for versioning.

`dvs_init` to creates

-   a **storage directory** to store versioned files.

-   a `dvs.yaml` in the project directory containing the path of the storage directory

In general, the storage directory should be named `/data/dvs/<project_name>`.

Creating the storage directory in `/data/dvs` ensures that it will be outside of the project directory and thus accessible company-wide.

```{r}
# for the purpose of this tutorial, use your name instead of the project name
# to avoid conflicts with others using this script

# replace <my_name> with your name 
my_storage_dir <- "/data/dvs/<my_name>"
dvs_init(my_storage_dir)
```

### 2: Add

Suppose I assembled a data set and saved it as a csv file.

```{r}
derDir <- "data/derived"
pk_data <- data.frame(
  USUBJID = c(1, 1, 1),
  NTFD = c(0.5, 1, 2),
  DV = c(379.444, 560.613, 0)
)

pk_data_path <- file.path(derDir, "pk_data.csv")
write.csv(pk_data, pk_data_path)
```

I'll use `dvs_add` to version this file with devious.

This will copy `pk_data.csv` to the storage directory previously initialized with `dvs_init`.

This will also create a metadata file for `pk_data.csv` called `pk_data.csv.dvsmeta` in its respective directory: `data/derived`.

In general, a metadata file will be generated in the same directory as its associated file and be called `<file_name>.dvsmeta`.

Each metadata file acts as a map for devious to locate the copied file later and for future collaborators to consult for versioning.

```{r}
# add the csv file to devious
added_files <- dvs_add(pk_data_path, message = "finished pk data assembly")
```

The message parameter is optional - if included, it will be in:

-   the metadata file (check it out in `data/derived`)

-   the output of `dvs_status` (more on this later).

```{r}
# view the output from dvs_add
added_files
```

Besides copying it to the storage_directory, some information about `pk_data.csv` is also returned, including the file hash in the `hash` column.

```{r}
added_files$hash
```

Notice that a `.gitignore` was also generated in `data/derived`.

The `.gitignore` contains an entry excluding `pk_data.csv,` so it isn't uploaded to github.\
You no longer have to manually create or update a `.gitignore` for files added to devious.

### 3: Update

Let's say I found a bug and want to update `pk_data.csv`.

```{r}
# say I want to update my data frame
pk_data <- data.frame(
  USUBJID = c(1, 1, 1),
  NTFD = c(0.5, 1, 2),
  DV = c(379.444, 560.613, 912.843)
)

write.csv(pk_data, pk_data_path)
```

To update a file I previously added to devious, I'll run `dvs_add` again with the same file path.

```{r}
# the message is optional
dvs_add(pk_data_path, message = "updated pk data with new data sent by client") 
```

Notice that when updating, the `outcome` column says `copied`.

If I add a version of a file that already exists on devious, the outcome is `present` For example, this happens when I add the updated version again:

```{r}
dvs_add(pk_data_path)
```

### 4: Push

Now if you push to github, you'll see that `pk_data.csv` isn't present in `data/derived`, but its metadata file and the `.gitignore` are.

![](github.png){width="213"}

The `.gitignore` lists `pk_data.csv` to exclude it from files added to github.

![](gitignore.png){width="368"}

The data file isn't on github, but the metadata file with directions to its location is!

### Multiple Files

Suppose I have many files in data/derived and I want to add them all to devious,

```{r}
# create some copies to generate multiple files
pk_data2_path <- file.path(derDir, "pk_data2.csv")
write.csv(pk_data, pk_data2_path)

pk_data3_path <- file.path(derDir, "pk_data3.csv")
write.csv(pk_data, pk_data3_path)
```

I could add them all by inputting a vector of the files like this:

```{r}
dvs_add(c(pk_data_path, pk_data2_path, pk_data3_path))
```

Or I can save time by using a file glob:

```{r}
dvs_add(file.path(derDir, "*"))

# which is equivalent to:
# dvs_add("data/derived/*")
```

In general, the `*` indicates every file/directory in a given directory, but devious manually filters out `.dvsmeta` and `.gitignore` files so these files can't be added.

### Errors

What happens when a file that doesn't exist is added?

```{r}
# dvs_add("this/isnt/a/file/path") # should panic
```

In this case, devious will panic.

For any other error, devious will indicate such in the outcome column

For example, devious may be unable to write to the `.gitignore`. The command will fail to perform its intended operation.

```{r}
# make the .gitignore un-writable 
system('chmod 333 data/derived/.gitignore')
add_error <- dvs_add(pk_data_path)
add_error
```

The error is given in the `error` column, and if an error message was returned, this will be in the `error_message` column.

```{r}
# investigate the error
add_error$error
add_error$error_message

# make the .gitignore writable again
system('chmod 777 data/derived/.gitignore')
```

Suppose many files were added, and as such, a data frame with many rows was returned.\
I can quickly check if any errors occurred by running:

```{r}
# number of errors = sum of values in the error column that aren't NA
paste("number of errors:", sum(!is.na(add_error$error))) # there should be 1 error
```

## The Analyst

Without devious, my workflow would be to hunt down the data assembly script and run it, which could take a long time for large data sets. Here is the proposed alternative devious workflow:

### 1: Pull

Because the `.gitignore` excludes them, a analyst pulling from github won't have any files added to devious by the assembler.

```{r}
# I'll simulate this situation by deleting the previously added files 
file.remove(c(pk_data_path, pk_data2_path, pk_data3_path))
```

### 2: Status

I'll run a status check in the console to see which files have been added to devious.

files in the `dvs_status` data frame will have one of the following `status` entries:

-   up-to-date

-   not-present

-   out-of-sync

    -   out-of-sync files may be ahead or behind current work

    -   if you know your work is behind the current version on devious, run `dvs_get` to retrieve it

-   error

    -   if there's an error getting the status of a file, for example if the file is a directory.

```{r}
dvs_status()
```

I might also want to just get a status report of files in a particular directory,\
in which case I can use the same file glob pattern I used before with `dvs_add`:

```{r}
dvs_status(file.path(derDir, "*"))
```

Or I can get the status of a single file.

```{r}
status <- dvs_status(pk_data_path)
status
```

Check for errors getting status:

```{r}
paste("number of errors:", sum(!is.na(status$error)))
```

### 3: Get

Now I'll retrieve the files I want with `dvs_get`.

This function copies files from the storage directory back into their respective directory within the git repo.\
The input can be the file itself or its metadata file.\
Like `dvs_add`, `dvs_get` can also receive inputted file globs, vectors of files, relative paths, and absolute paths.

```{r}
# copy pk_data.csv back into the project directory
get <- dvs_get(pk_data_path)
get
```

```{r}
# check if there were any errors
paste("number of errors:", sum(!is.na(get$error)))
```

### Piping Patterns

Here are some ways to use status and get in conjunction:

```{r}
# general piping pattern
dvs_status() %>% # status all previously added files
  pull(relative_path) %>% # select their relative paths
  dvs_get() # copy files to the project repo
```

```{r}
file.remove(pk_data_path)
file.remove(pk_data2_path)
file.remove(pk_data3_path)

# piping pattern to get all not-present and out-of-sync files from data/derived
dvs_status(file.path(derDir, "*")) %>% # status all files in data/derived
  filter(status == "not-present" | status == "out-of-sync") %>% # filter files with status "not-present" or "out-of-sync"
  pull(relative_path) %>%  # select their relative paths
  dvs_get() # copy files to the project repo
```

```{r}
file.remove(pk_data_path)
file.remove(pk_data2_path)
file.remove(pk_data3_path)

# piping pattern to get all files except for those up-to-date in data/derived
dvs_status(file.path(derDir, "*")) %>% # status all files in data/derived
  filter(status != "up-to-date") %>% # filter all files except for those up-to-date
  pull(relative_path) %>% # pull the paths
  dvs_get() # copy to project repo
```

## The QCer

Suppose I want to make sure that the current version of a file stored on devious is the same as the one generated by the script. For example, I'll QC `pk_data.csv`:\

I'll simulate pulling from github by deleting pk_data.csv

```{r}
file.remove(pk_data_path)
```

### 1: Get hash

I'll start by getting the hash of the file stored on devious with `dvs_status`

paste the following code into the console

```         
data <- "user_guide/tutorial/data/derived/pk_data.csv"
original <- dvs_status(data)$hash
```

### 2: Run script

Now re-run the Data Assembly script (re-copied here for convenience)

```{r}
pk_data <- data.frame(
  USUBJID = c(1, 1, 1),
  NTFD = c(0.5, 1, 2),
  DV = c(379.444, 560.613, 912.843)
)

write.csv(pk_data, pk_data_path)
```

### 3: Make hash

Now I'll generate the hash of the file I just created from running the script

paste the following code into the console

```         
current <- dvs_add(data)$hash
```

### 4: Compare

paste the following code into the console

```         
original == current
```

If these hashes are equal, then the file stored on devious is the same as the file generated by DA the script.

## Two Data Frame Output

Notice that files inputted to `dvs_add`, `dvs_get`, and `dvs_status` have NA in the `error` and `error_message` columns if the given operation was successful.\
When the operation fails, the columns `size`, `hash`, `message`, etc. are NA.\
In other words, there every row will have at least a couple NAs whether the file operation was successful or not.

```{r}
# for example
dvs_add(c(pk_data_path, "data"))
```

I can make the distinction between these outputs more clear with the `split_output` parameter, which returns two data frames: one with the files for which the operation was successful, and one with the those that failed.

```{r}
# the same file input, now with the split_output parameter
split <- dvs_add(c(pk_data_path, "data"), split_output = TRUE)
```

```{r}
# view the failures
split$failures
```

```{r}
# view the successes
split$successes
```

The output is much cleaner.

To quickly assess if any errors occurred, check if the `failures` data frame exists instead of checking for NAs:

```{r}
paste("no errors present:", !is.null(split$failures))
```

If there are errors present, I can check how many with `nrow`:

```{r}
paste("number of errors:", nrow(split$failures))
```

Thank you for following this tutorial. If you have any questions or ideas, reach out to Jenna Johnson jenna\@a2-ai.com

```{r}
# clean up
file.remove(pk_data_path)
file.remove(pk_data2_path)
file.remove(pk_data3_path)
file.remove(paste0(pk_data_path, ".dvsmeta"))
file.remove(paste0(pk_data2_path, ".dvsmeta"))
file.remove(paste0(pk_data3_path, ".dvsmeta"))
file.remove(file.path(derDir, ".gitignore"))
file.remove("~/Projects/Rdevious/dvs.yaml")
unlink(my_storage_dir, recursive=TRUE)
```
