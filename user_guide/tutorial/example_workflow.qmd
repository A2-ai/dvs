# Introduction to devious (the R package)

Devious is now an R package inspired by the original devious command line tool.

While it implements the same base functionality, it has some new features, and output is organized into data frames.

We can use devious to version data files without tracking them directly on github.

```{r}
# library(devious)
```

## Role: the Data Assembler

### Step 1: Initialize

Suppose I created a new repo for a project.\
I want to manage project data with devious, so I'll start with initialization.

In the devious package, `dvs_init` sets up a project for versioning.

I'll use `dvs_init` to create a storage directory for versioned files.\
This command also creates a `dvs.yaml` in the project directory with the path of the storage directory, which devious consults for future commands.

```{r}
# in general, the storage directory should be named "/data/dvs/<project_name>"
# this directory is outside of the project directory, in a directory accessible to everyone.
my_storage_dir <- "/data/dvs/tutorial"
dvs_init(my_storage_dir)
```

### Step 2: Add

Suppose I assembled this data set and saved it as a csv file.

```{r}
derDir <- "data/derived"
pk_data <- data.frame(
  USUBJID = c(1, 1, 1),
  NTFD = c(0.5, 1, 2),
  DV = c(379.444, 560.613, 0)
)

pk_data_path <- file.path(derDir, "pk_data.csv")
write.csv(pk_data, pk_data_path)
```

I'll use `dvs_add` to version this file with devious.

This will copy `pk_data.csv` to the storage directory previously initialized with `dvs_init`.

This will also create a metadata file for `pk_data.csv` called `pk_data.csv.dvsmeta` in its respective directory: `data/derived`.

In general, a generated metadata file will be called `<file_name>.dvsmeta`.

Each metadata file acts as a map for devious locate a given copied file later.

```{r}
# add the csv file to devious so it can be retrieved later
dvs_add(pk_data_path, message = "finished pk data assembly") # adding a message is optional
```

Notice that a `.gitignore` was also added to data/derived!\
You no longer have to manually create or update a `.gitignore` for files added to devious.

### Step 3: Update as needed

Let's say I found a bug and want to update `pk_data.csv` file

```{r}
# say I want to update my data frame
pk_data <- data.frame(
  USUBJID = c(1, 1, 1),
  NTFD = c(0.5, 1, 2),
  DV = c(379.444, 560.613, 912.842)
)

write.csv(pk_data, pk_data_path)
```

To update a file I previously added to devious, I'll run `dvs_add` again with the same file path.

```{r}
dvs_add(pk_data_path) 
```

Notice that when updating, the outcome is Success instead of Already Present.

### Step 4: Push to github

Now if you push to github, you'll see that `pk_data.csv` isn't present in `data/derived`, but its metadata file and the `.gitignore` are.

![](github.png){width="213"}

The `.gitignore` lists `pk_data.csv` to exclude it from files added to github.

![](gitignore.png){width="368"}

### Other Scenarios

#### Multiple Files

Suppose I have many files in data/derived and I want to add them all to devious,

```{r}
# create some copies to generate multiple files
pk_data2_path <- file.path(derDir, "pk_data2.csv")
write.csv(pk_data, pk_data2_path)

pk_data3_path <- file.path(derDir, "pk_data3.csv")
write.csv(pk_data, pk_data3_path)
```

I don't want to list them all in a vector like this:

```{r}
# dvs_add(c(pk_data_path, pk_data2_path, pk_data3_path))
```

So I'll save time by using a file glob:

```{r}
dvs_add(file.path(derDir, "*"))

# which is equivalent to:
# dvs_add("data/derived/*")
```

In general, the `*` indicates every file/directory in a given directory, but devious manually filters out `.dvsmeta` and `.gitignore` files so these files aren't added.

#### Errors

Let's experiment with adding a file that doesn't exist

```{r}
dvs_add("this/isnt/a/file/path") # should panic
```
Devious will panic if you try to add a file that doesn't exist.

For any other error, devious will indicate such in the outcome column

```{r}
# for example, let's try adding a directory instead of a file
dvs_add("data")
```

## Role: the Analyst

### Step 1: Pull from github
```{r}
# because the .gitignore excludes it, a analyst pulling from github won't have pk_data.csv
# I'll simulate this by running this chunk to delete the file 
file.remove(pk_data_path)
```

### Step 2: Status

Without devious, my workflow would be to hunt down the data assembly script and run it, which could take a long time for large data sets.

Suppose instead, I start my workflow by running a status check to see which files have been added to devious

```{r}
dvs_status()

# if you want to status files a specific file, you can do that too
# dvs_status(pk_data_path)
```

```{r}
# check if there were any errors
# number of errors = sum of values in the error column that aren't NA
sum(!is.na(status$error))
```

```{r}
# now we can get the file back
get <- dvs_get(pk_data_path)
get
```

```{r}
# check if there were any errors
sum(!is.na(get$error))
```

`dvs_status` will list files with one of the following statuses:

-   up-to-date

-   not-present

-   out-of-sync

    -   out-of-sync files may be ahead or behind current work

    -   if you believe your work is behind the current version on devious, run `dvs_get` to retrieve it

```{r}
file.remove(pk_data_path)
# here is an example piping pattern to get all not-present and out-of-sync files from data/derived
dvs_status(file.path(derDir, "*")) %>% filter(status != "up-to-date") %>% pull(relative_path) %>% dvs_get()
```

```{r}
# we can split up the output to give us a data frame for the successful files and error files
# by setting one_df to false
added_files <- dvs_add(c(pk_data_path, "data"), one_df = FALSE)
```

```{r}
# view the failures
added_files$failures
```

```{r}
# view the successes
added_files$successes
```

## Role: the QCer

```{r}
# clean up
file.remove(pk_data_path)
file.remove(pk_data2_path)
file.remove(pk_data3_path)
file.remove(paste0(pk_data_path, ".dvsmeta"))
file.remove(file.path(derDir, ".gitignore"))
file.remove("~/Projects/Rdevious/dvs.yaml")
unlink(my_storage_dir, recursive=TRUE)
```
