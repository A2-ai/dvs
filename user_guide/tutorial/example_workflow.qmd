---
title: "Introduction to devious (the R package)"
author: |
    | Prepared by:
    | Jenna Johnson
    | (jenna@a2-ai.com)
date: today
date-format: long
format:
  html:
    toc: true
    number-sections: true
    colorlinks: true
editor: visual
---

Devious is now an R package inspired by the original devious command line tool.

While it implements the same base functionality, it has some new features, and output is organized into data frames.

We can use devious to version data files without tracking them directly on github.

```{r}
# library(devious)
```

## Role: the Data Assembler

### Step 1: Initialize

Suppose I created a new repo for a project.\
I want to manage project data with devious, so I'll start with initialization.

In the devious package, `dvs_init` sets up a project for versioning.

I'll use `dvs_init` to create a storage directory for versioned files.\
This command also creates a `dvs.yaml` in the project directory with the path of the storage directory, which devious consults for future commands.

```{r}
# in general, the storage directory should be named "/data/dvs/<project_name>"
# this directory is outside of the project directory, in a directory accessible to everyone.
my_storage_dir <- "/data/dvs/tutorial"
dvs_init(my_storage_dir)
```

### Step 2: Add

Suppose I assembled this data set and saved it as a csv file.

```{r}
derDir <- "data/derived"
pk_data <- data.frame(
  USUBJID = c(1, 1, 1),
  NTFD = c(0.5, 1, 2),
  DV = c(379.444, 560.613, 0)
)

pk_data_path <- file.path(derDir, "pk_data.csv")
write.csv(pk_data, pk_data_path)
```

I'll use `dvs_add` to version this file with devious.

This will copy `pk_data.csv` to the storage directory previously initialized with `dvs_init`.

This will also create a metadata file for `pk_data.csv` called `pk_data.csv.dvsmeta` in its respective directory: `data/derived`.

In general, a generated metadata file will be called `<file_name>.dvsmeta`.

Each metadata file acts as a map for devious locate a given copied file later.

```{r}
# add the csv file to devious so it can be retrieved later
added_files <- dvs_add(pk_data_path, message = "finished pk data assembly") # adding a message is optional
added_files
```

Notice that a `.gitignore` was also added to data/derived!\
You no longer have to manually create or update a `.gitignore` for files added to devious.

Get the file hash

```{r}
added_files$hash
```

### Step 3: Update as needed

Let's say I found a bug and want to update `pk_data.csv` file

```{r}
# say I want to update my data frame
pk_data <- data.frame(
  USUBJID = c(1, 1, 1),
  NTFD = c(0.5, 1, 2),
  DV = c(379.444, 560.613, 912.842)
)

write.csv(pk_data, pk_data_path)
```

To update a file I previously added to devious, I'll run `dvs_add` again with the same file path.

```{r}
dvs_add(pk_data_path) 
```

Notice that when updating, the outcome is Success instead of Already Present.

### Step 4: Push to github

Now if you push to github, you'll see that `pk_data.csv` isn't present in `data/derived`, but its metadata file and the `.gitignore` are.

![](github.png){width="213"}

The `.gitignore` lists `pk_data.csv` to exclude it from files added to github.

![](gitignore.png){width="368"}

### Multiple Files

Suppose I have many files in data/derived and I want to add them all to devious,

```{r}
# create some copies to generate multiple files
pk_data2_path <- file.path(derDir, "pk_data2.csv")
write.csv(pk_data, pk_data2_path)

pk_data3_path <- file.path(derDir, "pk_data3.csv")
write.csv(pk_data, pk_data3_path)
```

I could add them all by inputting in a vector of each explicit file like this:

```{r}
dvs_add(c(pk_data_path, pk_data2_path, pk_data3_path))
```

Or I can save time by using a file glob:

```{r}
dvs_add(file.path(derDir, "*"))

# which is equivalent to:
# dvs_add("data/derived/*")
```

In general, the `*` indicates every file/directory in a given directory, but devious manually filters out `.dvsmeta` and `.gitignore` files so these files aren't added.

### Errors

Let's experiment with adding a file that doesn't exist

```{r}
dvs_add("this/isnt/a/file/path") # should panic
```

Devious will panic if you try to add a file that doesn't exist.

For any other error, devious will indicate such in the outcome column

```{r}
# for example, let's try adding a directory instead of a file
dvs_add("data")
```

Some other error examples include not being able to get the size or hash for a file. The reason for an error is given in the `error_type` column. If an error message was returned from a function, this will be in the `error_message` column.

```{r}
# investigate the error
add_dir$error
add_dir$error_message
```

Suppose many files were added, and as such, a data frame with many rows was returned.\
I can quickly check if any errors occurred by running:

```{r}
# number of errors = sum of values in the error column that aren't NA
paste("number of errors:", sum(!is.na(add_dir$error)))
```

## Role: the Analyst

Without devious, my workflow would be to hunt down the data assembly script and run it, which could take a long time for large data sets. Here is the proposed devious workflow:

### Step 1: Pull from github

Because the .gitignore excludes them, a analyst pulling from github won't have any files added to devious by the assembler.

```{r}
# I'll simulate this situation by running this chunk to delete the previously added files 
file.remove(c(pk_data_path, pk_data2_path, pk_data3_path))
```

### Step 2: Status

I start my workflow by running a status check to see which files have been added to devious.

files in the `dvs_status` data frame will have one of the following `status` entries:

-   up-to-date

-   not-present

-   out-of-sync

    -   out-of-sync files may be ahead or behind current work

    -   if you know your work is behind the current version on devious, run `dvs_get` to retrieve it

-   error

    -   if there's an error getting the status of a file, for example if the file is a directory.

```{r}
dvs_status()
```

I might also want to just get a status report of files in a particular directory,\
in which case I can use the same file glob pattern I used before with `dvs_add`:

```{r}
dvs_status(file.path(derDir, "*"))
```

Or I can get the status of a single file.

```{r}
status <- dvs_status(pk_data_path)
status
```

Check for errors getting status:

```{r}
paste("number of errors:", sum(!is.na(status$error)))
```

### Step 3: Get

Now I'll retrieve the files I want with `dvs_get`.

This function copies files from the storage directory back into their respective directory within the git repo.\
The input can be the file itself or its metadata file.\
Like `dvs_add`, `dvs_get` can also receive inputted file globs, vectors of files, relative paths, and absolute paths.

```{r}
# copy pk_data.csv back into the project directory
get <- dvs_get(pk_data_path)
get
```

```{r}
# check if there were any errors
paste("number of errors:", sum(!is.na(get$error)))
```

### Piping Patterns

Here are some ways to use status and get in conjunction:

```{r}
# general piping pattern
dvs_status() %>% # status all previously added files
  pull(relative_path) %>% # select their relative paths
  dvs_get() # copy files to the project repo
```

```{r}
file.remove(pk_data_path)
file.remove(pk_data2_path)
file.remove(pk_data3_path)

# piping pattern to get all not-present and out-of-sync files from data/derived
dvs_status(file.path(derDir, "*")) %>% # status all files in data/derived
  filter(status == "not-present" | status == "out-of-sync") %>% # filter files with status "not-present" or "out-of-sync"
  pull(relative_path) %>%  # select their relative paths
  dvs_get() # copy files to the project repo
```

```{r}
file.remove(pk_data_path)
file.remove(pk_data2_path)
file.remove(pk_data3_path)

# piping pattern to get all files except for those up-to-date in data/derived
dvs_status(file.path(derDir, "*")) %>% # status all files in data/derived
  filter(status != "up-to-date") %>% # filter all files except for those up-to-date
  pull(relative_path) %>% # pull the paths
  dvs_get() # copy to project repo
```

## Role: the QCer

```{r}
get <- dvs_get(pk_data_path)
qc_hash <- get$hash

paste("Assembly hash:", assembly_hash)
paste("QC hash:      ", qc_hash)

paste("Assembly hash == QC hash:", assembly_hash == qc_hash)
```

## Two Data Frame Output

```{r}
# we can split up the output to give us a data frame for the successful files and error files
# by setting one_df to false
added_files <- dvs_add(c(pk_data_path, "data"), one_df = FALSE)
```

```{r}
# view the failures
added_files$failures
```

```{r}
# view the successes
added_files$successes
```

```{r}
# clean up
file.remove(pk_data_path)
file.remove(pk_data2_path)
file.remove(pk_data3_path)
file.remove(paste0(pk_data_path, ".dvsmeta"))
file.remove(paste0(pk_data2_path, ".dvsmeta"))
file.remove(paste0(pk_data3_path, ".dvsmeta"))
file.remove(file.path(derDir, ".gitignore"))
file.remove("~/Projects/Rdevious/dvs.yaml")
unlink(my_storage_dir, recursive=TRUE)
```
