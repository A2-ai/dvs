---
title: "Introduction to devious (the R package)"
author: |
    | Prepared by:
    | Jenna Johnson
    | (jenna@a2-ai.com)
date: today
date-format: long
format:
  html:
    toc: true
    number-sections: true
    colorlinks: true
editor: visual
---

Devious is now an R package inspired by the original devious command line tool.

While it implements the same base functionality, it has some new features, and output is organized into data frames.

We can use devious to version data files without tracking them directly on github.

```{r}
# library(devious)
```

## Role: the Data Assembler

### Step 1: Initialize

Suppose I created a new repo for a project.\
I want to manage project data with devious, so I'll start with initialization.

In the devious package, `dvs_init` sets up a project for versioning.

I'll use `dvs_init` to create a storage directory for versioned files.\
This command also creates a `dvs.yaml` in the project directory with the path of the storage directory for devious to use in future commands.

In general, name the storage directory `/data/dvs/<project_name>`. Creating the directory in `/data/dvs/` ensures that it will be accessible company-wide and outside of the project directory.

```{r}
# for the purpose of this tutorial, replace {your name goes here} with your name 
# to avoid conflicts with others using this script
my_storage_dir <- "/data/dvs/tutorial_{your name goes here}"
dvs_init(my_storage_dir)
```

### Step 2: Add

Suppose I assembled a data set and saved it as a csv file.

```{r}
derDir <- "data/derived"
pk_data <- data.frame(
  USUBJID = c(1, 1, 1),
  NTFD = c(0.5, 1, 2),
  DV = c(379.444, 560.613, 0)
)

pk_data_path <- file.path(derDir, "pk_data.csv")
write.csv(pk_data, pk_data_path)
```

I'll use `dvs_add` to version this file with devious.

This will copy `pk_data.csv` to the storage directory previously initialized with `dvs_init`.

This will also create a metadata file for `pk_data.csv` called `pk_data.csv.dvsmeta` in its respective directory: `data/derived`.

In general, metadata file will be generated in the same directory as its associated file and be called `<file_name>.dvsmeta`.

Each metadata file acts as a map for devious to locate the copied file later.

```{r}
# add the csv file to devious
# the message is optional - if included, it will appear in the metadata file
added_files <- dvs_add(pk_data_path, message = "finished pk data assembly")
added_files
```

Some information about `pk_data.csv` is also returned in the data frame output, including the file hash in the `hash` column.

```{r}
added_files$hash
```

Notice that a `.gitignore` was also added to data/derived.

The `.gitignore` contains an entry excluding `pk_data.csv,` so it isn't tracked by github.\
You no longer have to manually create or update a `.gitignore` for files added to devious.

### Step 3: Update as needed

Let's say I found a bug and want to update `pk_data.csv` file

```{r}
# say I want to update my data frame
pk_data <- data.frame(
  USUBJID = c(1, 1, 1),
  NTFD = c(0.5, 1, 2),
  DV = c(379.444, 560.613, 912.843)
)

write.csv(pk_data, pk_data_path)
```

To update a file I previously added to devious, I'll run `dvs_add` again with the same file path.

```{r}
# the message is optional
dvs_add(pk_data_path, message = "updated pk data with new data sent by client") 
```

Notice that when updating, the outcome is Success instead of Already Present.

### Step 4: Push to github

Now if you push to github, you'll see that `pk_data.csv` isn't present in `data/derived`, but its metadata file and the `.gitignore` are.

![](github.png){width="213"}

The `.gitignore` lists `pk_data.csv` to exclude it from files added to github.

![](gitignore.png){width="368"}

### Multiple Files

Suppose I have many files in data/derived and I want to add them all to devious,

```{r}
# create some copies to generate multiple files
pk_data2_path <- file.path(derDir, "pk_data2.csv")
write.csv(pk_data, pk_data2_path)

pk_data3_path <- file.path(derDir, "pk_data3.csv")
write.csv(pk_data, pk_data3_path)
```

I could add them all by inputting in a vector of each explicit file like this:

```{r}
dvs_add(c(pk_data_path, pk_data2_path, pk_data3_path))
```

Or I can save time by using a file glob:

```{r}
dvs_add(file.path(derDir, "*"))

# which is equivalent to:
# dvs_add("data/derived/*")
```

In general, the `*` indicates every file/directory in a given directory, but devious manually filters out `.dvsmeta` and `.gitignore` files so these files aren't added.

### Errors

Let's experiment with adding a file that doesn't exist

```{r}
dvs_add("this/isnt/a/file/path") # should panic
```

Devious will panic if you try to add a file that doesn't exist.

For any other error, devious will indicate such in the outcome column

For example, devious may be unable to write to the .gitignore. The command will fail to perform its intended operation.

```{r}
# make the .gitignore un-writable 
system('chmod 333 data/derived/.gitignore')
add_error <- dvs_add(pk_data_path)
add_error
```

The error is given in the `error` column, and if an error message was returned, this will be in the `error_message` column.

```{r}
# investigate the error
add_error$error
add_error$error_message

# make the .gitignore writable again
system('chmod 777 data/derived/.gitignore')
```

Suppose many files were added, and as such, a data frame with many rows was returned.\
I can quickly check if any errors occurred by running:

```{r}
# number of errors = sum of values in the error column that aren't NA
paste("number of errors:", sum(!is.na(add_error$error))) # there should be 1 error
```

## Role: the Analyst

Without devious, my workflow would be to hunt down the data assembly script and run it, which could take a long time for large data sets. Here is the proposed alternative devious workflow:

### Step 1: Pull from github

Because the .gitignore excludes them, a analyst pulling from github won't have any files added to devious by the assembler.

```{r}
# I'll simulate this situation by deleting the previously added files 
file.remove(c(pk_data_path, pk_data2_path, pk_data3_path))
```

### Step 2: Status

I'll run a status check in the console to see which files have been added to devious.

files in the `dvs_status` data frame will have one of the following `status` entries:

-   up-to-date

-   not-present

-   out-of-sync

    -   out-of-sync files may be ahead or behind current work

    -   if you know your work is behind the current version on devious, run `dvs_get` to retrieve it

-   error

    -   if there's an error getting the status of a file, for example if the file is a directory.

```{r}
dvs_status()
```

I might also want to just get a status report of files in a particular directory,\
in which case I can use the same file glob pattern I used before with `dvs_add`:

```{r}
dvs_status(file.path(derDir, "*"))
```

Or I can get the status of a single file.

```{r}
status <- dvs_status(pk_data_path)
status
```

Check for errors getting status:

```{r}
paste("number of errors:", sum(!is.na(status$error)))
```

### Step 3: Get

Now I'll retrieve the files I want with `dvs_get`.

This function copies files from the storage directory back into their respective directory within the git repo.\
The input can be the file itself or its metadata file.\
Like `dvs_add`, `dvs_get` can also receive inputted file globs, vectors of files, relative paths, and absolute paths.

```{r}
# copy pk_data.csv back into the project directory
get <- dvs_get(pk_data_path)
get
```

```{r}
# check if there were any errors
paste("number of errors:", sum(!is.na(get$error)))
```

### Piping Patterns

Here are some ways to use status and get in conjunction:

```{r}
# general piping pattern
dvs_status() %>% # status all previously added files
  pull(relative_path) %>% # select their relative paths
  dvs_get() # copy files to the project repo
```

```{r}
file.remove(pk_data_path)
file.remove(pk_data2_path)
file.remove(pk_data3_path)

# piping pattern to get all not-present and out-of-sync files from data/derived
dvs_status(file.path(derDir, "*")) %>% # status all files in data/derived
  filter(status == "not-present" | status == "out-of-sync") %>% # filter files with status "not-present" or "out-of-sync"
  pull(relative_path) %>%  # select their relative paths
  dvs_get() # copy files to the project repo
```

```{r}
file.remove(pk_data_path)
file.remove(pk_data2_path)
file.remove(pk_data3_path)

# piping pattern to get all files except for those up-to-date in data/derived
dvs_status(file.path(derDir, "*")) %>% # status all files in data/derived
  filter(status != "up-to-date") %>% # filter all files except for those up-to-date
  pull(relative_path) %>% # pull the paths
  dvs_get() # copy to project repo
```

## Role: the QCer

Suppose I want to make sure that the current version of a file stored on devious is the same as the one generated by the script. 
For example, I'll QC `pk_data.csv`:\

I'll simulate pulling from github by deleting pk_data.csv
```{r}
file.remove(pk_data_path)
```

### Step 1: Get stored hash
I'll start by getting the hash of the file stored on devious with `dvs_status`

paste the following code into the console
``` 
data <- "user_guide/tutorial/data/derived/pk_data.csv"
original <- dvs_status(data)$hash
```

### Step 2: Run the DA script

Now re-run the Data Assembly script (re-copied here for convenience)
```{r}
pk_data <- data.frame(
  USUBJID = c(1, 1, 1),
  NTFD = c(0.5, 1, 2),
  DV = c(379.444, 560.613, 912.843)
)

write.csv(pk_data, pk_data_path)
```

### Step 3: Get current hash
Now I'll get the hash of the file I just generated from running the script

paste the following code into the console
```
current <- dvs_add(data)$hash
```

### Step 4: Compare

paste the following code into the console
```
original == current
```

If these hashes are equal, then the file stored on devious is the same as the file generated by DA the script.


## Two Data Frame Output

Notice that files inputted to `dvs_add`, `dvs_get`, and `dvs_status` have NA in the `error` and `error_message` columns if the given operation was successful.\
When the operation fails, the columns `size`, `hash`, `message`, etc. are NA.\
In other words, there every row will have at least a couple NAs whether the file operation was successful or not.

```{r}
# for example
dvs_add(c(pk_data_path, "data"))
```

I can make the distinction between these outputs more clear with the `split_output` parameter, which returns two data frames: one with the files for which the operation was successful, and one with the those that failed.

```{r}
# the same file input, now with the split_output parameter
split <- dvs_add(c(pk_data_path, "data"), split_output = TRUE)
```

```{r}
# view the failures
split$failures
```

```{r}
# view the successes
split$successes
```

The output is much cleaner.

To quickly assess if any errors occurred, check if the `failures` data frame exists instead of checking for NAs:

```{r}
paste("no errors present:", !is.null(split$failures))
```

If there are errors present, I can check how many with `nrow`:
```{r}
paste("number of errors:", nrow(split$failures))
```



Thank you for following this tutorial. If you have any questions or ideas, reach out to 
Jenna Johnson
jenna@a2-ai.com

```{r}
# clean up
file.remove(pk_data_path)
file.remove(pk_data2_path)
file.remove(pk_data3_path)
file.remove(paste0(pk_data_path, ".dvsmeta"))
file.remove(paste0(pk_data2_path, ".dvsmeta"))
file.remove(paste0(pk_data3_path, ".dvsmeta"))
file.remove(file.path(derDir, ".gitignore"))
file.remove("~/Projects/Rdevious/dvs.yaml")
unlink(my_storage_dir, recursive=TRUE)
```
